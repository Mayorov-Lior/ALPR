# -*- coding: utf-8 -*-
"""CharClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pmvQpin8dFcUB87sASQkC1qI9cowKSoH
"""

#from google.colab import drive
#drive.mount('/content/drive')

import cv2
import numpy as np
import sys
#sys.path.append("./drive/My Drive/lp_data")
from PlateExtractionSeg import splitData, prepareImgs
import keras

from keras.optimizers import Adam, SGD
from keras.models import Model
from keras.layers import Conv2D, MaxPooling2D, Add, Activation, Dense, Dropout, Flatten, Input

# PATH = '/content/drive/My Drive/lp_data/'
# PATH = 'C:/Users/Lior/Documents/work/License Plate Recognition/'
CHAR_IMG_SIZE = 28
CATAGORIES_NUM = 12 # 0,1,2,3,4,5,6,7,8,9,×¦,.
GARBAGE_INDEX = 11

class CustomSaver(keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if (epoch % 1 == 0):
      self.model.save_weights(PATH + "model_{}.hd5".format(epoch))
      print ('>>> saved after %d epochs.'%(epoch))
      
def createCharClassicationModel(train_X,train_y, fit=True):
  epochsNum = 5
  input_size = (CHAR_IMG_SIZE,CHAR_IMG_SIZE,3)
  inputs = Input(input_size)
  
  out = Conv2D(32, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(inputs)
  out = Conv2D(32, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(out)
  out = Dropout(0.25)(out)
  out = Conv2D(64, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(out)
  out = Conv2D(64, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(out)
  out = Conv2D(128, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(out)
  out = Conv2D(128, (3, 3), activation='relu', padding='same', kernel_initializer = 'he_normal')(out)

  out = Flatten()(out)
  out = Dense(100, activation='relu')(out)
  out = Dropout(0.5)(out)
  out = Dense(CATAGORIES_NUM, activation='softmax')(out)
    
  model = Model(input = [inputs], output = [out])  
  model.compile('adam', 'mse')
  model.summary()
  saver = CustomSaver()
  if fit:
    model.fit(train_X, train_y, epochs=epochsNum, validation_split=0.2, verbose=1)

  return model

def resizeCharImg(img):
  if len(img.shape) == 3:
    h,w = img.shape[:-1]
  else:
    h,w = img.shape
  
  diff = abs(w - h)
  add1 = int(diff/2.0)
  add2 = diff - add1
  if (w > h):
      resized = cv2.copyMakeBorder(img,add1,add2,0,0,cv2.BORDER_CONSTANT,value=[0,0,0])
  else:
      resized = cv2.copyMakeBorder(img,0,0,add1,add2,cv2.BORDER_CONSTANT,value=[0,0,0])
  resized = cv2.resize(resized, (CHAR_IMG_SIZE, CHAR_IMG_SIZE)) 
  return resized


def recognizeGarbage(ch):
  garbage = np.zeros((CATAGORIES_NUM,))
  garbage[GARBAGE_INDEX] = 1
  #print ('ch org: ', ch)
  #print ('garbage: ', ch[GARBAGE_INDEX])
  if ch[GARBAGE_INDEX] > 0.1:
    
    return garbage
  return ch

def predictCharArrays(model, X):
  pred = model.predict(X)
  # print ('pred org: ', pred)
  pred = np.array([recognizeGarbage(ch) for ch in pred])
  return pred.round().astype(int)
  
def predictChar(model, chImg):
  chImg = resizeCharImg(chImg)
  arr = predictCharArrays(model, np.array([chImg]))[0]
  for index in range(len(arr)):
    if (arr[index] == 1):
      if (index <= 9):
        return str(index)
      if index == 10:
        return 'm'
      return '.'
  return ':O'

def valueClassification(pred, test_y):
  charComp = lambda c1, c2: int((sum(c1 == c2))/CATAGORIES_NUM)
  val = 0
  index = 0
  for p, t in zip(pred, test_y):
    index += 1
    #if (index > 20):
    #  print (p)
    #  print (t)
    #  print (val)
    
    val += charComp(p,t)
    
  return (val/len(pred))

def testCharClassification(imgs, chars):    
  percent = 0.8
  train_X, test_X = prepareImgs(imgs, percent)
  train_y, test_y = splitData(chars, percent)

  model = createCharClassicationModel(train_X, train_y,True)
  model.save_weights(PATH + 'char_classification.h5')
  pred = model.predict(test_X)
  
  train_y, test_y = splitData(chars, 0.8)
  print ('Accuracy: ', valueClassification(pred, test_y))
  
  return model, pred

from tensorflow.keras.models import load_model

# imgs = np.load(PATH + 'PerCharacter/nparrays/' + 'charsImagesDataSet.npy')
# chars = np.load(PATH + 'PerCharacter/nparrays/' + 'charsDataSet.npy')
# print ('data loaded...')
# #model, pred = testCharClassification(imgs, chars)
# model = load_model(PATH + 'models/char_classification_colab.h5')
# pred = predictCharArrays(model, imgs)
# one = np.zeros()
# index = chars[chars == ]
# #print (pred[0])
# #print (chars[0])
# print (valueClassification(pred, chars))